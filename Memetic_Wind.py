import math
import numpy as np
import matplotlib.pyplot as plt
import datetime
import os
import time

folder_name = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")

# Hyperparameters for GA
N_iterations = 1000
pop_size = 10 # Population size use even numbers
mutation_rate = 0.02  # Mutation rate
crossover_rate = 0.9  # Crossover rate

#parameters of Turbine
N_turbines = 100
R_diameter = 200 #in meters

#parameters of windfarm

wind_dir = 270 # in degC
Air_den = 1.2 # UK's avg density of air in kg/m3
wind_speed = 17 #in m/s
Cef = 0.15 #power coefficient
Ct = 0.5 #thrust cofficient
k = 0.05 #wake decay coff for offshore consideration

#cost_of_turbine = 1000000


#Grid parameters
tot_area = 300_000_000 #in square meter
col_dist = 3*(R_diameter/2)
row_dist = 5*(R_diameter/2)

no_of_col = math.floor(math.sqrt(tot_area)/row_dist)
no_of_row = math.floor(math.sqrt(tot_area)/col_dist)


def initialize_random_layout(rows,cols,no_of_turbines):
    # Create a numpy array of zeros
    array = np.zeros((rows, cols), dtype=int)

    # Make sure num_ones is not greater than the total number of elements in the array
    no_of_turbines = min(no_of_turbines, rows * cols)

    # Get random indices without replacement to avoid setting the same position to 1 multiple times
    random_indices = np.random.choice(rows * cols, no_of_turbines, replace=False)

    # Set the random positions to 1
    array.flat[random_indices] = 1
    return array #, random_indices


def Wake_effect(grid_layout):
    A = (3.14) * ((R_diameter/2)**2) #swept Area
    P_matrix = np.zeros((no_of_row,no_of_col))
    Vdf = np.zeros((no_of_row,no_of_col))
    Dwk = np.zeros((no_of_row,no_of_col))
    for i in range(no_of_row):
        for j in range(no_of_col):
            if j==0 and grid_layout[i][j] == 1:
                P_matrix [i][j]=0.5* Air_den * A * Cef * (wind_speed**3) #Power generated by wind turbine * (10**-6) #megawatt
            else:    
                if(grid_layout[i][j] == 1):
                    c_j = j
                    c_empty = 0
                    while c_j > 0:
                        if grid_layout[i][c_j-1] == 0 :
                            c_empty +=1
                        else:
                            break
                        c_j=c_j-1
                    # s should be = col_dist + (col_dist * c_empty)
                    s= 5.*R_diameter + ((5.*R_diameter)*c_empty)
                    Dwk[i][j]=R_diameter +  (2 * k * s)
                    Vdf[i][j]=wind_speed * ((1 - (math.sqrt(1-Ct))) * ((R_diameter/(Dwk[i][j]))**2))
                    P_matrix [i][j]=0.5 * Air_den * A * Cef * ((wind_speed-Vdf[i][j])**3)        
                        
                else:
                    Vdf[i][j] = 0
                    P_matrix[i][j] = 0           
    return P_matrix

def plot_farm(farm_layout,title='',save_image=False,figure_name=''):

    #plt.figure()
    fig,ax = plt.subplots(1)
    plt.imshow(farm_layout,aspect='equal',cmap='gray_r')
    ax.set_yticklabels([])
    ax.set_xticklabels([])
    ax.set_ylabel(f'{no_of_row} kms')
    ax.set_xlabel(f'{no_of_col} kms')
    plt.title(title)
    #plt.axis('off')
    #plt.colorbar()
    if save_image:
        plt.savefig(figure_name)
    else:
        plt.show()
    plt.close()

#Mosetti cost fuction uisng just the number of turbines
def calculate_cost(N_turbines):
    return (N_turbines * ((2/3)+((1/3) * (np.exp((-0.00174*((N_turbines)**2)))))))



farm_grid = initialize_random_layout(no_of_row,no_of_col,N_turbines)
print(farm_grid)
plot_farm(farm_layout=farm_grid,title='Randomized Initial layout')
# print(np.sum(farm_grid))
# print(farm_grid)

farm_grid_after_wake = Wake_effect(farm_grid)
# plot_farm(farm_grid_after_wake)
power_output_of_farm = np.sum(farm_grid_after_wake)/1*10**6
# print("farm's total power output",power_output_of_farm)

objective_function = calculate_cost(N_turbines)/power_output_of_farm
# print(f'objective function {objective_function}')
# print(farm_grid_after_wake)

# Implement genetic algorithm

# Function to evaluate the fitness of individuals in the population
def evaluate_fitness(population):
    fitness_scores = []
    for layout in population:
        farm_grid_after_wake = Wake_effect(layout.reshape((no_of_row, no_of_col)))
        power_output_of_farm = np.sum(farm_grid_after_wake) / 1e6  # Convert to MW
        cost = calculate_cost(N_turbines)
        fitness = cost / power_output_of_farm
        fitness_scores.append(-fitness)
    return np.array(fitness_scores)

def is_valid_move(layout, row, col):

    if 0 <= row < layout.shape[0] and 0 <= col < layout.shape[1] and layout[row, col] == 0:
        return True
    return False

def perform_random_move(layout):
    new_layout = layout.copy()
    turbines = np.argwhere(layout == 1)
    # print(turbines)
    
    for turbine in turbines:
        valid_moves = []
        for dr in [-2,-1, 0, 1,2]:
            for dc in [-2,-1, 0, 1,2]:
                new_row, new_col = turbine[0] + dr, turbine[1] + dc
                if (dr == 0 and dc == 0) or not (0 <= new_row < layout.shape[0] and 0 <= new_col < layout.shape[1]):
                    continue
                # print('old position',(turbine[0],turbine[1]),'new position',(new_row,new_col))
                if is_valid_move(new_layout, new_row, new_col):
                    valid_moves.append((new_row, new_col))
        # print(valid_moves)
        if valid_moves:
            new_position = valid_moves[np.random.choice(len(valid_moves))]
            new_layout[turbine[0], turbine[1]] = 0
            new_layout[new_position[0], new_position[1]] = 1
    
    return new_layout

def hill_climbing(layout, iterations):
    current_layout = layout.copy()
    current_fitness = evaluate_fitness([current_layout.flatten()])
    
    for _ in range(iterations):
        new_layout = perform_random_move(current_layout)
        new_fitness = evaluate_fitness([new_layout.flatten()])
        
        if new_fitness > current_fitness:
            current_layout = new_layout
            current_fitness = new_fitness
    
    return current_layout, current_fitness

# Function for selection using tournament selection
def selection(population, fitness_scores):
    selected_indices = np.random.choice(len(population), size=pop_size // 2, replace=False)
    selected_population = population[selected_indices]
    selected_fitness_scores = fitness_scores[selected_indices]
    return selected_population, selected_fitness_scores


# Function for crossover (single-point crossover with constraint)
def crossover(parent1, parent2):
    crossover_point = np.random.randint(len(parent1))
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))

    # Enforce the constraint to maintain the number of turbines (1s) in the child layouts
    if np.sum(child1) > N_turbines:
        num_extra_turbines = np.sum(child1) - N_turbines
        nonzero_indices = np.nonzero(child1)
        random_indices = np.random.choice(nonzero_indices[0], num_extra_turbines, replace=False)
        child1[random_indices] = 0

    if np.sum(child2) > N_turbines:
        num_extra_turbines = np.sum(child2) - N_turbines
        nonzero_indices = np.nonzero(child2)
        random_indices = np.random.choice(nonzero_indices[0], num_extra_turbines, replace=False)
        child2[random_indices] = 0

    return child1, child2

# Function for mutation (randomly flip bits with a certain probability)
def mutate(layout):
    # Calculate the number of turbines in the current layout
    num_turbines = np.sum(layout)

    # Find indices that can be mutated to add a turbine (1)
    add_turbine_indices = np.where(layout == 0)[0]

    # Find indices that can be mutated to remove a turbine (0)
    remove_turbine_indices = np.where(layout == 1)[0]

    for i in range(len(layout)):
        if np.random.rand() < mutation_rate:
            # Mutate to add a turbine (1) if there are still available positions
            if num_turbines < N_turbines and len(add_turbine_indices) > 0:
                idx = np.random.choice(add_turbine_indices)
                layout[idx] = 1
                add_turbine_indices = np.delete(add_turbine_indices, np.where(add_turbine_indices == idx))
                num_turbines += 1
            # Mutate to remove a turbine (0) if there are turbines present
            elif num_turbines > 0 and len(remove_turbine_indices) > 0:
                idx = np.random.choice(remove_turbine_indices)
                layout[idx] = 0
                remove_turbine_indices = np.delete(remove_turbine_indices, np.where(remove_turbine_indices == idx))
                num_turbines -= 1

    return layout

# Main genetic algorithm function
def genetic_algorithm(N_iterations):
    # population = np.random.randint(2, size=(pop_size, no_of_row * no_of_col))
    # print(farm_grid.flatten())
    population = np.array([initialize_random_layout(no_of_row,no_of_col,N_turbines).flatten() for s in range(pop_size)])
    best_layout = None
    best_fitness = float('-inf')

    for pop_no,each in enumerate(population):
        each_layout_power = Wake_effect(each.reshape((no_of_row, no_of_col)))
        power_output_of_layout = np.sum(each_layout_power) / 1e6
        print(f"Population {pop_no} initial power output is {power_output_of_layout}")

    for iteration in range(N_iterations):
        # if iteration % 25 == 0: start_time = time.time()
        fitness_scores = evaluate_fitness(population)
        # if iteration % 25 == 0: print(f'For Iteration {iteration}. evaluate_fitness function took',time.time() - start_time,'seconds')
        best_layout_index = np.argmax(fitness_scores)
        current_best_fitness = fitness_scores[best_layout_index]

        if current_best_fitness > best_fitness:
            best_layout = population[best_layout_index]

            try: os.mkdir(folder_name)
            except FileExistsError: pass

            # if iteration % 25 == 0: start_time = time.time()
            # plot_farm(best_layout.reshape(no_of_row, no_of_col),save_image=True,figure_name=f"{folder_name}/population_{best_layout_index}_{iteration}.png")
            # if iteration % 25 == 0: print(f'For Iteration {iteration}. plot_farm and saving function took',time.time() - start_time,'seconds')

            best_fitness = current_best_fitness
        
        selected_population, selected_fitness_scores = selection(population, fitness_scores)

        new_population = []
        for i in range(pop_size // 2):
            parent1 = selected_population[i]
            parent2 = selected_population[(i + 1) % (pop_size // 2)]  # Use modulo to wrap around the indices
            if np.random.rand() < crossover_rate:
                child1, child2 = crossover(parent1, parent2)
                new_population.append(child1)
                new_population.append(child2)
            else:
                new_population.append(parent1)
                new_population.append(parent2)


        population = np.array(new_population)

        if iteration % 25 == 0: start_time = time.time()
        for i in range(pop_size):
            population[i] = mutate(population[i])
        if iteration % 25 == 0: print(f'For Iteration {iteration}. mutating all populations took',time.time() - start_time,'seconds')

    return best_layout.reshape((no_of_row, no_of_col)), best_layout_index

start_time = time.time()
# Run genetic algorithm
best_layout, population_number = genetic_algorithm(N_iterations)
print("--- genetic algorithm took %s seconds ---" % (time.time() - start_time))

# Plot the best wind farm layout found by the genetic algorithm
plot_farm(farm_layout=best_layout,title='Best Layout after GA')

# Calculate and print the power output of the best layout
best_farm_grid_after_wake = Wake_effect(best_layout)

best_power_output_of_farm = np.sum(best_farm_grid_after_wake) / 1e6
print(f"Best farm layout originated from population {population_number} and total power output is {best_power_output_of_farm} MW")

print('Initial Layout')
# print(layout)
# plot_farm(best_layout)
initial_fitness = evaluate_fitness([best_layout.flatten()])
print('initial fitness',initial_fitness)
optimized_layout, best_fitness = hill_climbing(layout=best_layout,iterations=N_iterations)

print("Optimized Layout:")
plot_farm(optimized_layout,title='Optimized Layout by LS')
print("Best Fitness:", best_fitness)

print('Improvement in fitness = ',best_fitness[0]-initial_fitness[0])
# Calculate and print the power output of the best layout optimized
best_farm_grid_after_optimization = Wake_effect(optimized_layout)
best_power_output_of_farm_optimized = np.sum(best_farm_grid_after_optimization) / 1e6
print(f"Best farm layout originated from population {population_number} and total power output is {best_power_output_of_farm_optimized} MW")
